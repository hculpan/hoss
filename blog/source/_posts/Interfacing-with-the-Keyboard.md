---
title: Interfacing with the Keyboard
date: 2019-02-27 14:24:36
tags:
---
So the keyboard device driver has been the most fun thing I've worked on so far, mostly just because it's been where I've been able to break away from other people's code and start doing my own thing with HOSS.

I started with the basic driver that Fenollosa presented (this being on area where Brundell had a reference in his table of contents but no text).  Really, this was just test code.  It setup a keyboard interrupt handler, converted the scancode into an ASCII character (for the printable ones), put each character in a buffer, and echoed this out to the screen.  If you pressed Enter/Return, it echoed the buffer and then cleared it.  If you typed "END", it would halt the processor.  It did handle the Shift key, so a 1 was always a 1 even when you held the Shift key; letters were always capital.  But all this code, including displaying the output and processing special characters like Return or Backspace, were handled in the driver.  Obviously this was just test code and not the final state of his keyboard driver, but it was the last bit of such code Fenollosa had in his tutorial, so this is what I had to start with.

The first thing I added was processing of the Shift key.  The keyboard interface itself doesn't help you here.  Whenever a key is pressed or released, the keyboard interrupt service routine is called with the scancode of the key (which is different than the ASCII value), but otherwise that's basically all you get.  So, for example, if someone pressed A, you don't one value if they're holding the Shift and another value if they're not.  You just get the scancode (30 for the A, btw).  When they press the Shift, you get a separate call to the interrupt routine for the Shift key scancode.  So I added a static member to the keyboard driver called `shiftPressed`, and when the ISR was called with the Shift being pressed, I set this to ON (1).  When it was called with the Shift being raised (indicated by the same scancode + 128), I set this to OFF (0).  Then when the user typed an A, I translated this to `A` if the shiftPressed was ON and `a` if the shiftPressed was off.  Technically I did this by having two arrays of characters, with the scancode being the index to the array.  The first was when shiftPressed was OFF; the second when shiftPressed was ON.  This let me easily handle all the printable keys: The letters, numbers, and special characters like `$` and `/`.  Though I haven't actually done so yet, that will be my same approach for the Ctrl and Alt keys.

At this point, I thought about supporting the Caps Lock key, but there's a further complication with that.  The keyboard ISR is called when the Caps Lock is pressed and released, but that again has no impact on anything.  Of course, setting up another static variable to track the Caps Lock key is no big deal, but here's the rub.  The Caps Lock has an LED indicator so the user can determine if it's on or not.  One can control that using the data port interface of the keyboard, but I just haven't figured out how to do that yet.  So for the moment the Caps Lock remains unused.

So after I did the above, it was just a matter of moving all the non-keyboard code out of the driver, and providing a routine for apps to call.  I created one called `waitForAscii`, which just waits until a printable key is pressed and returns the ASCII value.  It ignores anything like Ctrl or the function keys.  It also doesn't work with the number pad yet, even though those are printable.  Even though it won't return a Shift, it does modify the ASCII appropriately based on the status of the Shift key.

My future plan is to provide a mechanism for polling the keyboard that won't block, and to give equivalent methods that include extended keys as well.  I also want to add support for the number pad even to the standard ASCII routines.  But these enhancements are for a little ways down the road.  My one blocking method supporting only ASCII keys will serve me for the moment as I begin my next task, building the basics of a command shell.